<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0f172a">
  <title>Device Details - SAJ Solar Monitor</title>
  <link rel="stylesheet" href="/design-system/styles.css">
  <style>
    body {
      padding-bottom: 80px;
    }

    .device-header {
      background: var(--color-bg-secondary);
      padding: var(--space-4);
      margin: -16px -16px var(--space-4) -16px;
      border-bottom: 1px solid var(--color-bg-tertiary);
    }

    .device-title {
      font-size: 20px;
      font-weight: 600;
      color: var(--color-text-primary);
      margin-bottom: var(--space-1);
    }

    .device-subtitle {
      color: var(--color-text-secondary);
      font-size: 14px;
    }

    .chart-container {
      background: var(--color-bg-secondary);
      border-radius: var(--radius-lg);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
      border: 1px solid var(--color-bg-tertiary);
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-3);
    }

    .chart-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--color-text-primary);
    }

    .chart-period {
      color: var(--color-text-secondary);
      font-size: 12px;
    }

    .chart-placeholder {
      height: 200px;
      background: linear-gradient(135deg, var(--color-bg-tertiary), var(--color-bg-primary));
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-text-secondary);
      border: 2px dashed var(--color-bg-tertiary);
    }

    .energy-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--space-3);
      margin-bottom: var(--space-4);
    }

    .stat-card {
      background: var(--color-bg-secondary);
      padding: var(--space-3);
      border-radius: var(--radius-md);
      text-align: center;
      border: 1px solid var(--color-bg-tertiary);
    }

    .stat-value {
      font-size: 24px;
      font-weight: 700;
      color: var(--color-solar-energy);
      margin-bottom: var(--space-1);
    }

    .stat-label {
      color: var(--color-text-secondary);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .loading {
      opacity: 0.5;
      pointer-events: none;
    }

    .error-state {
      text-align: center;
      padding: var(--space-8);
      color: var(--color-text-secondary);
    }

    .back-button {
      position: absolute;
      left: var(--space-4);
      top: 50%;
      transform: translateY(-50%);
      color: var(--color-text-secondary);
      text-decoration: none;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <a href="/devices" class="back-button">‚Üê</a>
    <h1 class="header-title">üìä Device Details</h1>
    <button id="refreshBtn" class="btn btn-ghost btn-sm">
      <span id="refreshIcon">üîÑ</span>
    </button>
  </header>

  <!-- Main Content -->
  <main class="container">
    <!-- Device Info -->
    <section class="mb-6">
      <div class="device-header">
        <div>
          <div class="device-title" id="deviceName">Loading...</div>
          <div class="device-subtitle" id="deviceInfo">Loading device information...</div>
        </div>
        <div id="deviceStatus" class="badge badge-online">Online</div>
      </div>
    </section>

    <!-- Energy Statistics -->
    <section class="mb-6">
      <div class="energy-stats">
        <div class="stat-card">
          <div class="stat-value" id="todayEnergy">--</div>
          <div class="stat-label">Today (kWh)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="totalEnergy">--</div>
          <div class="stat-label">Total (kWh)</div>
        </div>
      </div>
    </section>

    <!-- Historical Charts -->
    <section class="mb-6">
      <h3 class="text-h3 mb-4">Historical Data</h3>

      <!-- Yesterday Chart -->
      <div class="chart-container">
        <div class="chart-header">
          <div>
            <div class="chart-title">üìÖ Yesterday</div>
            <div class="chart-period" id="yesterdayPeriod">Loading...</div>
          </div>
          <button id="refreshYesterday" class="btn btn-ghost btn-sm">üîÑ</button>
        </div>
        <div class="chart-placeholder" id="yesterdayChart">
          <div>üìä Loading yesterday's data...</div>
        </div>
      </div>

      <!-- Last 7 Days Chart -->
      <div class="chart-container">
        <div class="chart-header">
          <div>
            <div class="chart-title">üìà Last 7 Days</div>
            <div class="chart-period" id="weekPeriod">Loading...</div>
          </div>
          <button id="refreshWeek" class="btn btn-ghost btn-sm">üîÑ</button>
        </div>
        <div class="chart-placeholder" id="weekChart">
          <div>üìä Loading 7-day data...</div>
        </div>
      </div>

      <!-- Last Month Chart -->
      <div class="chart-container">
        <div class="chart-header">
          <div>
            <div class="chart-title">üìä Last Month</div>
            <div class="chart-period" id="monthPeriod">Loading...</div>
          </div>
          <button id="refreshMonth" class="btn btn-ghost btn-sm">üîÑ</button>
        </div>
        <div class="chart-placeholder" id="monthChart">
          <div>üìä Loading monthly data...</div>
        </div>
      </div>
    </section>

    <!-- Error State -->
    <div id="errorState" class="error-state" style="display: none;">
      <p>Unable to load device data. Please check the device SN and try again.</p>
      <button id="retryBtn" class="btn btn-primary mt-4">Retry</button>
    </div>
  </main>

  <!-- Bottom Navigation -->
  <nav class="bottom-nav">
    <a href="/" class="nav-item">
      <div class="nav-icon">üè†</div>
      <span>Dashboard</span>
    </a>
    <a href="/devices" class="nav-item nav-item-active">
      <div class="nav-icon">üì±</div>
      <span>Devices</span>
    </a>
    <a href="/sync" class="nav-item">
      <div class="nav-icon">üîÑ</div>
      <span>Sync</span>
    </a>
    <a href="/settings" class="nav-item">
      <div class="nav-icon">‚öôÔ∏è</div>
      <span>Settings</span>
    </a>
  </nav>

  <script>
    // Device Details functionality
    class DeviceDetails {
      constructor() {
        this.deviceSn = this.getDeviceSnFromUrl();
        this.init();
      }

      getDeviceSnFromUrl() {
        const path = window.location.pathname;
        const match = path.match(/\/device\/(.+)/);
        return match ? match[1] : null;
      }

      async init() {
        if (!this.deviceSn) {
          this.showError('Invalid device SN');
          return;
        }

        await this.loadDeviceData();
        this.setupEventListeners();
      }

      setupEventListeners() {
        const refreshBtn = document.getElementById('refreshBtn');
        refreshBtn.addEventListener('click', () => this.refreshAllData());

        // Individual chart refresh buttons
        document.getElementById('refreshYesterday').addEventListener('click', () => this.loadYesterdayChart());
        document.getElementById('refreshWeek').addEventListener('click', () => this.loadWeekChart());
        document.getElementById('refreshMonth').addEventListener('click', () => this.loadMonthChart());

        // Retry button
        document.getElementById('retryBtn').addEventListener('click', () => this.init());
      }

      async loadDeviceData() {
        try {
          this.showLoading(true);

          // Load device info
          await this.loadDeviceInfo();

          // Load all charts
          await Promise.all([
            this.loadYesterdayChart(),
            this.loadWeekChart(),
            this.loadMonthChart()
          ]);

        } catch (error) {
          console.error('Failed to load device data:', error);
          this.showError('Failed to load device data');
        } finally {
          this.showLoading(false);
        }
      }

      async loadDeviceInfo() {
        try {
          // Get device info from our database
          const response = await fetch(`/api/devices/${this.deviceSn}`);
          if (!response.ok) throw new Error('Device not found');

          const device = await response.json();
          this.updateDeviceInfo(device);

          // Also try to get real-time data for current stats
          await this.loadRealtimeData();

        } catch (error) {
          console.error('Failed to load device info:', error);
          // Try to get basic info from URL parameter
          document.getElementById('deviceName').textContent = `Device ${this.deviceSn}`;
          document.getElementById('deviceInfo').textContent = 'Device information not available';
        }
      }

      async loadRealtimeData() {
        try {
          const response = await fetch(`/api/devices/${this.deviceSn}/realtime`);
          if (response.ok) {
            const realtimeData = await response.json();
            this.updateRealtimeStats(realtimeData);
          }
        } catch (error) {
          console.log('Real-time data not available, using placeholder');
          // Keep placeholder values
        }
      }

      async loadYesterdayChart() {
        try {
          // Get yesterday's date range for hourly data
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          yesterday.setHours(0, 0, 0, 0); // Start of yesterday

          const today = new Date();
          today.setHours(0, 0, 0, 0); // Start of today

          const startTime = yesterday.toISOString().slice(0, 19).replace('T', ' ');
          const endTime = today.toISOString().slice(0, 19).replace('T', ' ');

          console.log(`üìä Loading yesterday chart: ${startTime} to ${endTime}`);

          // Use historyDataCommon API for detailed hourly data (as per SAJ documentation)
          const response = await fetch(`/api/devices/${this.deviceSn}/historical?startTime=${encodeURIComponent(startTime)}&endTime=${encodeURIComponent(endTime)}`);

          if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ Yesterday historical data loaded:', data);

            // Transform historical data format to match chart expectations
            const transformedData = this.transformHistoricalData(data, 'hourly');
            this.renderHourlyChart('yesterdayChart', transformedData, 'Yesterday\'s Hourly Generation');
            document.getElementById('yesterdayPeriod').textContent = yesterday.toLocaleDateString();
          } else {
            const errorText = await response.text();
            console.error('‚ùå Yesterday historical API error:', response.status, errorText);
            this.showChartError('yesterdayChart', `Failed to load yesterday's data (${response.status})`);
          }
        } catch (error) {
          console.error('‚ùå Failed to load yesterday chart:', error);
          this.showChartError('yesterdayChart', 'Error loading yesterday\'s data');
        }
      }

      async loadWeekChart() {
        try {
          // Get past 7 days for daily data (timeUnit=1)
          const endDate = new Date();
          endDate.setHours(23, 59, 59, 999); // End of today

          const startDate = new Date();
          startDate.setDate(endDate.getDate() - 7);
          startDate.setHours(0, 0, 0, 0); // Start of 7 days ago

          const startTime = startDate.toISOString().slice(0, 19).replace('T', ' ');
          const endTime = endDate.toISOString().slice(0, 19).replace('T', ' ');

          console.log(`üìä Loading 7-day chart: ${startTime} to ${endTime}`);

          // Use uploadData API with timeUnit=1 (daily data) - CORRECT for 7-day chart
          const response = await fetch(`/api/devices/${this.deviceSn}/uploadData?startTime=${encodeURIComponent(startTime)}&endTime=${encodeURIComponent(endTime)}&timeUnit=1`);

          if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ 7-day uploadData loaded:', data);

            // Transform uploadData format to match chart expectations
            const transformedData = this.transformUploadData(data, 'daily');
            this.renderDailyChart('weekChart', transformedData, '7-Day Generation Trend');
            document.getElementById('weekPeriod').textContent = `${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}`;
          } else {
            const errorText = await response.text();
            console.error('‚ùå 7-day uploadData API error:', response.status, errorText);
            this.showChartError('weekChart', `Failed to load 7-day data (${response.status})`);
          }
        } catch (error) {
          console.error('‚ùå Failed to load 7-day chart:', error);
          this.showChartError('weekChart', 'Error loading 7-day data');
        }
      }

      async loadMonthChart() {
        try {
          // Get past 30 days for daily data (timeUnit=1)
          const endDate = new Date();
          endDate.setHours(23, 59, 59, 999); // End of today

          const startDate = new Date();
          startDate.setDate(endDate.getDate() - 30);
          startDate.setHours(0, 0, 0, 0); // Start of 30 days ago

          const startTime = startDate.toISOString().slice(0, 19).replace('T', ' ');
          const endTime = endDate.toISOString().slice(0, 19).replace('T', ' ');

          console.log(`üìä Loading 30-day chart: ${startTime} to ${endTime}`);

          // Use uploadData API with timeUnit=1 (daily data) - CORRECT for 30-day chart
          const response = await fetch(`/api/devices/${this.deviceSn}/uploadData?startTime=${encodeURIComponent(startTime)}&endTime=${encodeURIComponent(endTime)}&timeUnit=1`);

          if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ 30-day uploadData loaded:', data);

            // Transform uploadData format to match chart expectations
            const transformedData = this.transformUploadData(data, 'daily');
            this.renderDailyChart('monthChart', transformedData, '30-Day Generation Trend');
            document.getElementById('monthPeriod').textContent = `${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}`;
          } else {
            const errorText = await response.text();
            console.error('‚ùå 30-day uploadData API error:', response.status, errorText);
            this.showChartError('monthChart', `Failed to load monthly data (${response.status})`);
          }
        } catch (error) {
          console.error('‚ùå Failed to load 30-day chart:', error);
          this.showChartError('monthChart', 'Error loading monthly data');
        }
      }

      // Transform uploadData API response to format expected by charts
      transformUploadData(uploadResponse, chartType) {
        console.log(`üîÑ Transforming uploadData for ${chartType} chart:`, uploadResponse);

        if (!uploadResponse || uploadResponse.code !== 200 || !uploadResponse.data?.data) {
          console.error('‚ùå Invalid uploadData response:', uploadResponse);
          return { code: 400, msg: 'Invalid data format', data: [] };
        }

        // Extract the data array from uploadData format
        const uploadDataPoints = uploadResponse.data.data;

        // Transform to format expected by existing renderChart function
        // uploadData gives us: { dataTime: "2025-08-26 00:00:00", pVEnergy: 23.65 }
        // renderChart expects: { dataTime: "...", totalPVPower: power_value }

        const transformedData = uploadDataPoints.map(point => ({
          dataTime: point.dataTime,
          totalPVPower: (point.pVEnergy || 0) * 1000, // Convert kWh to Wh for power simulation
          todayPvEnergy: point.pVEnergy || 0, // Keep original energy value
          // Add any other fields the chart might need
          deviceSn: this.deviceSn
        }));

        console.log(`‚úÖ Transformed ${transformedData.length} data points for ${chartType}`);
        console.log('üîç Sample transformed point:', transformedData[0]);

        return {
          code: 200,
          msg: 'success',
          data: transformedData
        };
      }

      // Transform historical API response to format expected by charts
      transformHistoricalData(historicalResponse, chartType) {
        console.log(`üîÑ Transforming historical data for ${chartType} chart:`, historicalResponse);

        if (!historicalResponse || historicalResponse.code !== 200 || !historicalResponse.data) {
          console.error('‚ùå Invalid historical response:', historicalResponse);
          return { code: 400, msg: 'Invalid data format', data: [] };
        }

        // Historical data comes as array of data points
        const historicalDataPoints = Array.isArray(historicalResponse.data) ? historicalResponse.data : [historicalResponse.data];

        // Transform to format expected by chart functions
        // Historical data has many fields, we need totalPVPower for the chart
        const transformedData = historicalDataPoints.map(point => ({
          dataTime: point.dataTime,
          totalPVPower: parseFloat(point.totalPVPower) || 0,
          todayPvEnergy: parseFloat(point.todayPvEnergy) || 0,
          deviceSn: this.deviceSn,
          // Keep other useful fields
          pv1Power: point.pv1Power,
          pv2Power: point.pv2Power,
          rGridPowerWatt: point.rGridPowerWatt
        }));

        console.log(`‚úÖ Transformed ${transformedData.length} historical data points for ${chartType}`);
        console.log('üîç Sample historical point:', transformedData[0]);

        return {
          code: 200,
          msg: 'success',
          data: transformedData
        };
      }

      updateDeviceInfo(device) {
        document.getElementById('deviceName').textContent = device.plant_name || `Device ${device.device_sn}`;
        document.getElementById('deviceInfo').textContent = `${device.device_type} ‚Ä¢ ${device.country}`;

        const statusElement = document.getElementById('deviceStatus');
        if (device.is_alarm) {
          statusElement.textContent = 'Alarm';
          statusElement.className = 'badge badge-alarm';
        } else {
          statusElement.textContent = device.is_online ? 'Online' : 'Offline';
          statusElement.className = `badge ${device.is_online ? 'badge-online' : 'badge-offline'}`;
        }
      }

      updateRealtimeStats(realtimeData) {
        if (realtimeData.todayPvEnergy) {
          document.getElementById('todayEnergy').textContent = parseFloat(realtimeData.todayPvEnergy).toFixed(2);
        }
        if (realtimeData.totalPvEnergy) {
          document.getElementById('totalEnergy').textContent = parseFloat(realtimeData.totalPvEnergy).toFixed(1);
        }
      }

      renderChart(chartId, data, title) {
        const chartElement = document.getElementById(chartId);
        console.log(`Rendering chart ${chartId} with title: ${title}`);
        console.log('Data received:', data);
        
        // Remove chart-placeholder styling to avoid dual container effect
        chartElement.style.background = 'none';
        chartElement.style.border = 'none';
        chartElement.style.height = 'auto';
        chartElement.style.display = 'block';
        chartElement.style.padding = '0';
        chartElement.style.alignItems = 'initial';
        chartElement.style.justifyContent = 'initial';

        // Check if data exists and has the correct structure
        if (!data || data.code !== 200) {
          console.error(`Invalid data format for ${chartId}:`, data);
          chartElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #ef4444;">‚ùå Invalid data format</div>';
          return;
        }

        // For historical data, the data array is directly in response.data
        // For real-time data, response.data is a single object
        let dataPoints = [];
        if (Array.isArray(data.data)) {
          // Historical data - array of data points
          dataPoints = data.data;
        } else if (data.data && typeof data.data === 'object') {
          // Real-time data - single object, convert to array for consistency
          dataPoints = [data.data];
        }

        if (dataPoints.length === 0) {
          chartElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #94a3b8;">üìä No data available for this period</div>';
          return;
        }

        // Simple bar chart visualization
        const maxPower = Math.max(...dataPoints.map(d => parseFloat(d.totalPVPower) || 0));

        if (maxPower === 0) {
          chartElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #94a3b8;">üìä No power generation data available</div>';
          return;
        }

        // Create smooth area chart with SVG (like reference design)
        const chartHeight = 200;
        
        // Create fixed time grid from 5am to 9pm with sub-hourly points for smoother curves
        const createTimeGrid = () => {
          const startHour = 5; // 5am
          const endHour = 21;  // 9pm
          const timePoints = [];
          
          // Create points every 30 minutes for smoother interpolation
          for (let hour = startHour; hour <= endHour; hour += 0.5) {
            const wholeHour = Math.floor(hour);
            const minutes = (hour % 1) * 60;
            const timeLabel = `${wholeHour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            
            timePoints.push({
              hour,
              timeLabel,
              x: ((hour - startHour) / (endHour - startHour)) * 100,
              power: 0, // default to 0, will be updated with real data
              isMainHour: minutes === 0 // Track main hours for labeling
            });
          }
          
          return timePoints;
        };
        
        const timeGrid = createTimeGrid();
        
        // Map actual data to time grid with interpolation
        dataPoints.forEach(point => {
          const pointTime = new Date(point.dataTime);
          const pointHour = pointTime.getHours() + pointTime.getMinutes() / 60;
          const power = parseFloat(point.totalPVPower) || 0;
          
          // Find closest time slot in our grid (within 30 minute window)
          const closestGridPoint = timeGrid.reduce((closest, current) => {
            const currentDiff = Math.abs(current.hour - pointHour);
            const closestDiff = Math.abs(closest.hour - pointHour);
            return currentDiff < closestDiff ? current : closest;
          });
          
          if (closestGridPoint) {
            closestGridPoint.power = Math.max(closestGridPoint.power, power);
          }
        });
        
        // Generate SVG path for smooth curve using time grid
        let pathData = '';
        let areaPath = '';
        const points = timeGrid.map(gridPoint => ({
          x: gridPoint.x,
          y: ((maxPower - gridPoint.power) / maxPower) * 80 + 10, // 10% padding top/bottom
          power: gridPoint.power,
          time: gridPoint.timeLabel,
          hour: gridPoint.hour
        }));

        if (points.length > 0) {
          // Create ultra-smooth curve using cubic bezier with cardinal spline interpolation
          pathData = `M ${points[0].x} ${points[0].y}`;
          areaPath = `M ${points[0].x} 90 L ${points[0].x} ${points[0].y}`;
          
          // Function to calculate smooth control points for cardinal spline
          const getControlPoints = (p0, p1, p2, p3, tension = 0.3) => {
            const t = tension;
            const cp1x = p1.x + (p2.x - (p0 ? p0.x : p1.x)) * t;
            const cp1y = p1.y + (p2.y - (p0 ? p0.y : p1.y)) * t;
            const cp2x = p2.x - (p3 ? p3.x - p1.x : p2.x - p1.x) * t;
            const cp2y = p2.y - (p3 ? p3.y - p1.y : p2.y - p1.y) * t;
            return { cp1x, cp1y, cp2x, cp2y };
          };
          
          for (let i = 1; i < points.length; i++) {
            const p0 = points[i - 2] || points[i - 1]; // Previous point or current if first
            const p1 = points[i - 1]; // Current point
            const p2 = points[i]; // Next point
            const p3 = points[i + 1] || points[i]; // Point after next or current if last
            
            const controls = getControlPoints(p0, p1, p2, p3, 0.25);
            
            // Use cubic bezier for ultra-smooth curves
            pathData += ` C ${controls.cp1x} ${controls.cp1y}, ${controls.cp2x} ${controls.cp2y}, ${p2.x} ${p2.y}`;
            areaPath += ` C ${controls.cp1x} ${controls.cp1y}, ${controls.cp2x} ${controls.cp2y}, ${p2.x} ${p2.y}`;
          }
          
          // Close the area path
          areaPath += ` L ${points[points.length - 1].x} 90 Z`;
        }

        let chartHTML = `
          <div style="padding: 20px; background: #1e293b; border-radius: 12px; margin: 8px 0; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
            <div style="font-size: 14px; color: #cbd5e1; margin-bottom: 20px; text-align: center; font-weight: 500;">
              ${title} (${dataPoints.length} data points)
            </div>
            
            <!-- SVG Chart Container -->
            <div style="position: relative; height: ${chartHeight}px; margin-bottom: 20px; background: #0f172a; border-radius: 8px; padding: 16px;">
              <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" style="overflow: visible; display: block;">
                <!-- Grid lines (optional) -->
                <defs>
                  <linearGradient id="areaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#2563eb;stop-opacity:0.9" />
                    <stop offset="25%" style="stop-color:#3b82f6;stop-opacity:0.6" />
                    <stop offset="75%" style="stop-color:#1e40af;stop-opacity:0.3" />
                    <stop offset="100%" style="stop-color:#1e3a8a;stop-opacity:0.1" />
                  </linearGradient>
                </defs>
                
                <!-- Area fill -->
                ${areaPath ? `<path d="${areaPath}" fill="url(#areaGradient)" />` : ''}
                
                <!-- Line stroke -->
                ${pathData ? `<path d="${pathData}" fill="none" stroke="#2563eb" stroke-width="1" />` : ''}
                
                <!-- Data points (dots) -->
                ${points.map(point => `
                  <circle cx="${point.x}" cy="${point.y}" r="0.4" fill="#2563eb" opacity="0.9">
                    <title>${point.time}: ${point.power.toFixed(0)}W</title>
                  </circle>
                `).join('')}
              </svg>
              
              <!-- Time labels -->
              <div style="position: absolute; bottom: -25px; left: 16px; right: 16px; display: flex; justify-content: space-between;">
                ${points.filter(point => point.hour % 3 === 0 && point.hour % 1 === 0).map(point => `
                  <span style="font-size: 10px; color: #64748b; text-align: center; min-width: 30px;">
                    ${Math.floor(point.hour).toString().padStart(2, '0')}:00
                  </span>
                `).join('')}
              </div>
            </div>
            
            <!-- Chart Summary -->
            <div style="
              border-top: 1px solid #334155; 
              padding-top: 16px; 
              font-size: 13px; 
              color: #cbd5e1;
              display: flex;
              justify-content: space-between;
              flex-wrap: wrap;
              gap: 12px;
            ">
              <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 8px; height: 8px; background: #2563eb; border-radius: 50%;"></div>
                <span><strong>Peak:</strong> ${maxPower.toFixed(0)}W</span>
              </div>
              <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 8px; height: 8px; background: #3b82f6; border-radius: 50%;"></div>
                <span><strong>Avg:</strong> ${(dataPoints.reduce((sum, d) => sum + (parseFloat(d.totalPVPower) || 0), 0) / dataPoints.length).toFixed(0)}W</span>
              </div>
              <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 8px; height: 8px; background: #1e40af; border-radius: 50%;"></div>
                <span><strong>Energy:</strong> ${(dataPoints.reduce((sum, d) => sum + (parseFloat(d.todayPvEnergy) || 0), 0)).toFixed(2)}kWh</span>
              </div>
            </div>
          </div>
        `;

        chartElement.innerHTML = chartHTML;
      }

      // Render hourly chart (for yesterday data)
      renderHourlyChart(chartId, data, title) {
        const chartElement = document.getElementById(chartId);
        console.log(`Rendering hourly chart ${chartId} with title: ${title}`);
        console.log('Data received:', data);

        // Remove chart-placeholder styling
        chartElement.style.background = 'none';
        chartElement.style.border = 'none';
        chartElement.style.height = 'auto';
        chartElement.style.display = 'block';
        chartElement.style.padding = '0';
        chartElement.style.alignItems = 'initial';
        chartElement.style.justifyContent = 'initial';

        if (!data || data.code !== 200) {
          console.error(`Invalid data format for ${chartId}:`, data);
          chartElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #ef4444;">‚ùå Invalid data format</div>';
          return;
        }

        let dataPoints = [];
        if (Array.isArray(data.data)) {
          dataPoints = data.data;
        } else if (data.data && typeof data.data === 'object') {
          dataPoints = [data.data];
        }

        if (dataPoints.length === 0) {
          chartElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #94a3b8;">üìä No data available for this period</div>';
          return;
        }

        const maxPower = Math.max(...dataPoints.map(d => parseFloat(d.totalPVPower) || 0));

        if (maxPower === 0) {
          chartElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #94a3b8;">üìä No power generation data available</div>';
          return;
        }

        // Create hourly time grid (5am to 9pm)
        const chartHeight = 200;

        const createHourlyGrid = () => {
          const startHour = 5; // 5am
          const endHour = 21;  // 9pm
          const timePoints = [];

          for (let hour = startHour; hour <= endHour; hour++) {
            timePoints.push({
              hour,
              timeLabel: `${hour.toString().padStart(2, '0')}:00`,
              x: ((hour - startHour) / (endHour - startHour)) * 100,
              power: 0
            });
          }

          return timePoints;
        };

        const timeGrid = createHourlyGrid();

        // Map actual data to hourly grid
        dataPoints.forEach(point => {
          const pointTime = new Date(point.dataTime);
          const pointHour = pointTime.getHours();
          const power = parseFloat(point.totalPVPower) || 0;

          const gridPoint = timeGrid.find(grid => grid.hour === pointHour);
          if (gridPoint) {
            gridPoint.power = Math.max(gridPoint.power, power);
          }
        });

        // Generate SVG path
        let pathData = '';
        let areaPath = '';
        const points = timeGrid.map(gridPoint => ({
          x: gridPoint.x,
          y: ((maxPower - gridPoint.power) / maxPower) * 80 + 10,
          power: gridPoint.power,
          time: gridPoint.timeLabel,
          hour: gridPoint.hour
        }));

        if (points.length > 0) {
          pathData = `M ${points[0].x} ${points[0].y}`;
          areaPath = `M ${points[0].x} 90 L ${points[0].x} ${points[0].y}`;

          for (let i = 1; i < points.length; i++) {
            const p0 = points[i - 1];
            const p1 = points[i];
            const cp1x = p0.x + (p1.x - p0.x) * 0.5;
            const cp1y = p0.y;
            const cp2x = p1.x - (p1.x - p0.x) * 0.5;
            const cp2y = p1.y;

            pathData += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
            areaPath += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
          }

          areaPath += ` L ${points[points.length - 1].x} 90 Z`;
        }

        let chartHTML = `
          <div style="padding: 20px; background: #1e293b; border-radius: 12px; margin: 8px 0; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
            <div style="font-size: 14px; color: #cbd5e1; margin-bottom: 20px; text-align: center; font-weight: 500;">
              ${title} (${dataPoints.length} data points)
            </div>

            <div style="position: relative; height: ${chartHeight}px; margin-bottom: 20px; background: #0f172a; border-radius: 8px; padding: 16px;">
              <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" style="overflow: visible; display: block;">
                <defs>
                  <linearGradient id="hourlyAreaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#2563eb;stop-opacity:0.9" />
                    <stop offset="25%" style="stop-color:#3b82f6;stop-opacity:0.6" />
                    <stop offset="75%" style="stop-color:#1e40af;stop-opacity:0.3" />
                    <stop offset="100%" style="stop-color:#1e3a8a;stop-opacity:0.1" />
                  </linearGradient>
                </defs>

                <path d="${areaPath}" fill="url(#hourlyAreaGradient)" />
                <path d="${pathData}" fill="none" stroke="#2563eb" stroke-width="1" />

                ${points.map(point => `
                  <circle cx="${point.x}" cy="${point.y}" r="0.4" fill="#2563eb" opacity="0.9">
                    <title>${point.time}: ${point.power.toFixed(0)}W</title>
                  </circle>
                `).join('')}
              </svg>

              <div style="position: absolute; bottom: -25px; left: 16px; right: 16px; display: flex; justify-content: space-between;">
                ${points.filter(point => point.hour % 3 === 0).map(point => `
                  <span style="font-size: 10px; color: #64748b; text-align: center; min-width: 30px;">
                    ${Math.floor(point.hour).toString().padStart(2, '0')}:00
                  </span>
                `).join('')}
              </div>
            </div>

            <div style="border-top: 1px solid #334155; padding-top: 16px; font-size: 13px; color: #cbd5e1; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 12px;">
              <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 8px; height: 8px; background: #2563eb; border-radius: 50%;"></div>
                <span><strong>Peak:</strong> ${maxPower.toFixed(0)}W</span>
              </div>
              <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 8px; height: 8px; background: #3b82f6; border-radius: 50%;"></div>
                <span><strong>Avg:</strong> ${(dataPoints.reduce((sum, d) => sum + (parseFloat(d.totalPVPower) || 0), 0) / dataPoints.length).toFixed(0)}W</span>
              </div>
              <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 8px; height: 8px; background: #1e40af; border-radius: 50%;"></div>
                <span><strong>Energy:</strong> ${(dataPoints.reduce((sum, d) => sum + (parseFloat(d.todayPvEnergy) || 0), 0)).toFixed(2)}kWh</span>
              </div>
            </div>
          </div>
        `;

        chartElement.innerHTML = chartHTML;
      }

      // Render daily chart (for 7-day and 30-day data)
      renderDailyChart(chartId, data, title) {
        const chartElement = document.getElementById(chartId);
        console.log(`Rendering daily chart ${chartId} with title: ${title}`);
        console.log('Data received:', data);

        // Remove chart-placeholder styling
        chartElement.style.background = 'none';
        chartElement.style.border = 'none';
        chartElement.style.height = 'auto';
        chartElement.style.display = 'block';
        chartElement.style.padding = '0';
        chartElement.style.alignItems = 'initial';
        chartElement.style.justifyContent = 'initial';

        if (!data || data.code !== 200) {
          console.error(`Invalid data format for ${chartId}:`, data);
          chartElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #ef4444;">‚ùå Invalid data format</div>';
          return;
        }

        let dataPoints = [];
        if (Array.isArray(data.data)) {
          dataPoints = data.data;
        } else if (data.data && typeof data.data === 'object') {
          dataPoints = [data.data];
        }

        if (dataPoints.length === 0) {
          chartElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #94a3b8;">üìä No data available for this period</div>';
          return;
        }

        const maxEnergy = Math.max(...dataPoints.map(d => parseFloat(d.todayPvEnergy) || 0));

        if (maxEnergy === 0) {
          chartElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #94a3b8;">üìä No energy generation data available</div>';
          return;
        }

        // Create daily time grid
        const chartHeight = 200;
        const timeGrid = dataPoints.map((point, index) => ({
          index,
          date: new Date(point.dataTime).toLocaleDateString(),
          x: (index / (dataPoints.length - 1)) * 100,
          energy: parseFloat(point.todayPvEnergy) || 0
        }));

        // Generate SVG path for daily chart
        let pathData = '';
        let areaPath = '';
        const points = timeGrid.map(gridPoint => ({
          x: gridPoint.x,
          y: ((maxEnergy - gridPoint.energy) / maxEnergy) * 80 + 10,
          energy: gridPoint.energy,
          date: gridPoint.date,
          index: gridPoint.index
        }));

        if (points.length > 0) {
          pathData = `M ${points[0].x} ${points[0].y}`;
          areaPath = `M ${points[0].x} 90 L ${points[0].x} ${points[0].y}`;

          for (let i = 1; i < points.length; i++) {
            const p0 = points[i - 1];
            const p1 = points[i];
            const cp1x = p0.x + (p1.x - p0.x) * 0.5;
            const cp1y = p0.y;
            const cp2x = p1.x - (p1.x - p0.x) * 0.5;
            const cp2y = p1.y;

            pathData += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
            areaPath += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
          }

          areaPath += ` L ${points[points.length - 1].x} 90 Z`;
        }

        let chartHTML = `
          <div style="padding: 20px; background: #1e293b; border-radius: 12px; margin: 8px 0; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
            <div style="font-size: 14px; color: #cbd5e1; margin-bottom: 20px; text-align: center; font-weight: 500;">
              ${title} (${dataPoints.length} data points)
            </div>

            <div style="position: relative; height: ${chartHeight}px; margin-bottom: 20px; background: #0f172a; border-radius: 8px; padding: 16px;">
              <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" style="overflow: visible; display: block;">
                <defs>
                  <linearGradient id="dailyAreaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#10b981;stop-opacity:0.9" />
                    <stop offset="25%" style="stop-color:#34d399;stop-opacity:0.6" />
                    <stop offset="75%" style="stop-color:#059669;stop-opacity:0.3" />
                    <stop offset="100%" style="stop-color:#047857;stop-opacity:0.1" />
                  </linearGradient>
                </defs>

                <path d="${areaPath}" fill="url(#dailyAreaGradient)" />
                <path d="${pathData}" fill="none" stroke="#10b981" stroke-width="1" />

                ${points.map(point => `
                  <circle cx="${point.x}" cy="${point.y}" r="0.4" fill="#10b981" opacity="0.9">
                    <title>${point.date}: ${point.energy.toFixed(2)}kWh</title>
                  </circle>
                `).join('')}
              </svg>

              <div style="position: absolute; bottom: -25px; left: 16px; right: 16px; display: flex; justify-content: space-between;">
                ${points.filter((point, index) => index % Math.ceil(points.length / 5) === 0).map(point => `
                  <span style="font-size: 10px; color: #64748b; text-align: center; min-width: 40px;">
                    ${point.date.split('/')[1]}/${point.date.split('/')[0]}
                  </span>
                `).join('')}
              </div>
            </div>

            <div style="border-top: 1px solid #334155; padding-top: 16px; font-size: 13px; color: #cbd5e1; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 12px;">
              <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 8px; height: 8px; background: #10b981; border-radius: 50%;"></div>
                <span><strong>Peak:</strong> ${maxEnergy.toFixed(2)}kWh</span>
              </div>
              <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 8px; height: 8px; background: #34d399; border-radius: 50%;"></div>
                <span><strong>Avg:</strong> ${(dataPoints.reduce((sum, d) => sum + (parseFloat(d.todayPvEnergy) || 0), 0) / dataPoints.length).toFixed(2)}kWh</span>
              </div>
              <div style="display: flex; align-items: center; gap: 6px;">
                <div style="width: 8px; height: 8px; background: #059669; border-radius: 50%;"></div>
                <span><strong>Total:</strong> ${(dataPoints.reduce((sum, d) => sum + (parseFloat(d.todayPvEnergy) || 0), 0)).toFixed(2)}kWh</span>
              </div>
            </div>
          </div>
        `;

        chartElement.innerHTML = chartHTML;
      }

      showChartError(chartId, message) {
        const chartElement = document.getElementById(chartId);
        chartElement.innerHTML = `<div style="color: var(--color-solar-alarm);">‚ö†Ô∏è ${message}</div>`;
      }

      async refreshAllData() {
        const refreshIcon = document.getElementById('refreshIcon');
        refreshIcon.style.animation = 'spin 1s linear infinite';

        await this.loadDeviceData();

        setTimeout(() => {
          refreshIcon.style.animation = '';
        }, 1000);
      }

      showLoading(loading) {
        document.body.classList.toggle('loading', loading);
      }

      showError(message) {
        document.getElementById('errorState').style.display = 'block';
        document.querySelector('main').style.display = 'none';
        console.error(message);
      }
    }

    // Initialize device details when page loads
    document.addEventListener('DOMContentLoaded', () => {
      new DeviceDetails();
    });
  </script>
</body>
</html>